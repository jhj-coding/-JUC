### 面向对象特性

封装，继承，多态

### a=a+b与a+=b 区别

a+=b 会把结果的数据类型强转为a的类型

### 3*0.1 == 0.3 将会返回什么? true 还是 false?

返回 false 因为浮点数不精确

### 能在 Switch 中使用 String 吗?

可以，本质使用的是其Hashcode

### 对equals()和hashCode()的理解?

重写equals 方法时必须重写hashCode方法，因为equals 相等则两个对象相等，两个对象相等其hashcode必须相等，hashcode相等 两个对象不一定相等因为有hash冲突

### final、finalize 和 finally 的不同之处?

final用于修饰变量 方法 类，final修饰的变量不可变

finalize方法在对象没有被引用，垃圾回收器回收时会调用

finally 用于try cache 方法结束时调用

### String、StringBuffer与StringBuilder的区别？

String 是不可变的

StringBuffer和StringBuilder是可变的

String StringBuffer是线程安全的 StringBuilder线程不安全

### 接口与抽象类的区别？

子类可以实现多个接口 只能继承一个抽象类

接口没有构造方法 抽象类可以有构造方法

接口不能有普通成员变量 抽象类可以有普通成员变量

接口静态成员变量只能是public static 抽象类可以随意

接口必须有抽象方法 抽象类可以没有抽象方法

接口不能有静态方法方法 抽象类可以有静态方法

接口的方法只能是pubilc abstract 抽象类可以public protect

###  this() & super()在构造方法中的区别？

this是指针 super是关键字

子类通过super 调用父类方法 只能在第一行使用

this 在构造函数中调用本类方法 只能在第一行使用

this 不能调用两个

this super 不能用在静态环境

### Java移位运算符？

左移 右移负数补1 无符号右移

### 为什么需要泛型？

不同类型的数据使用相同方法

编译检查 类型安全

### 泛型类如何定义使用？

```java
public Class T{
    
}
```

### 泛型接口如何定义使用？

```
public Interface T{
    
}
```

### 泛型方法如何定义使用？

```
public <T> T test(Class<T> t){
return t.newInstance()
}
```

### 泛型的上限和下限？

上限 继承extends  下限父类 super

### 如何理解Java中的泛型是伪泛型？

在编译器会进行泛型擦除，将泛型转换为真正使用的类型，因此称为伪泛型。

### 注解的作用？

编译检查

生成文档

编译时动态处理

运行时动态处理

### 注解的常见分类？

jdk 提供的注解 @Overide @Swaring @Dec

自定义注解

元注解

@Retation 保留到哪个运行时期

@Target 作用对象

@Inte 可继承

@Document 生成文档

### Java异常类层次结构?

父类 Throwable

Exception Error

RunEcception 编译时异常

### 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？

可查异常 就是编译时异常 不处理 变异不用过

不可查异常就是 运行时异常和错误 是在运行期间可能会发生的异常

### throw和throws的区别？

throw 用于抛出一个新的异常

throws 用于声明异常 便于让其他方法发现该方法有什么异常

### Java 7 的 try-with-resource?

实现autocloseable 的类可以在try with 中等到try catch方法执行完成时自动关闭资源

### 异常的底层？

异常的底层是有一个异常表，记录了从哪到哪 发生异常 解决异常的是在第几行 抛出的是什么异常

### 什么是反射？

在程序运行过程中，可以获取类的信息和方法可以获取到对象的信息和方法，这种动态获取信息的方法称为反射

### 反射的使用？

加载类 class.forname .class .getClass

构造方法

方法

属性

### getName、getCanonicalName与getSimpleName的区别?

getName 类的全限定名

getCanonicalName 类的全限定名 便于输出

getSimpleName 只有类名

### 什么是SPI机制？

spi 机制是jdk 提供的服务发现提供机制，供插件扩展和框架扩展

将实现方放到外面，自行选择实现方式

### SPI机制的应用？

数据库连接池 有多种数据库连接池 只要导进来包就会自动选择 就是利用SPI机制

### SPI机制的简单示例？

写一个接口 多个类实现接口 要使用那个 在resource Meta-Inf/Services 下创建服务接口命名文件 文件里写类全限定名

利用serviceLoad 加载接口 即可找到

### 集合有哪些类？

set HashSet 无序（和插入顺序不一致） LinkedHashSet 有序 TreeSet 红黑树 有序

List ArrayList LinkedList Verot（线程安全） CopyonWriteList

Queue LinkedList 实现栈和队列 PrioriQueue (堆)

### ArrayList的底层？

ArrayList 底层是数组 每次插入前会判断一下是否到达最大容量，如果达到则进行扩容 扩容是拷贝数组

### ArrayList自动扩容？

插入前会判断一下 如果达到则调用ensureCapi方法进行扩容 里面调用grow 方法 扩容为原来的1.5倍

### ArrayList的Fail-Fast机制？

里面有一个modCount 计数器，记录ArrayList 被修改的次数，如果在循环过程中发现次数不一样则会报错，可以使用迭代器的删除进行删除。

### Map有哪些类？

HashMap

LinkedHashMap

HashTable

ConCurrentHashMap

TreeMap

### JDK7 HashMap如何实现？

是分段锁 数组 链表 扩容 初始容量*负载因子

### JDK8 HashMap如何实现？

是数组 链表 红黑树

### HashSet是如何实现的？

hashSet是对HashMap的简单包装，其本质实现方法还是调用HashMap中的方法。

### 多线程的出现是要解决什么问题的? 本质什么?

多线程出现主要是为了解决CPU io 内存 速度差异大问题

为了解决cpu与内存差异 增加了缓存 造成了可见性问题

为了解决Cpu与io差异 增加线程 进程 分时复用 造成原子性问题

编译器进行指令重排序 造成有序性问题

### Java是怎么解决并发问题的?

jmm java内存模型

内存屏障

happens-before规则

Sychornized

volatile

final

### 线程安全有哪些实现思路?

阻塞同步

锁

非阻塞同步

CAS 内存模型

无锁

同一个方法内 没有调用其他同步共享代码

同一个线程 线程本地存储

### 如何理解并发和并行的区别?

并发 指的是一个CPU同时处理多个任务

并行 指的是 多核CPU处理多个不同任务

### 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?

新建 运行 阻塞 等待 无限等待 死亡

new start sleep wait wait stop

### 通常线程有哪几种使用方式?

Runable

callable

Thread

### 基础线程机制有哪些?

Executor

守护线程

join

yeild

### 线程的中断方式有哪些?

interpet

interpeted

showdown showdownnow

### 线程的互斥同步方式有哪些? 如何比较和选择?

Sychornize rertranlock

非公平 公平非公平

不可中断 可中断

一个条件 多个条件

jvm jdk

性能差不多

### 线程之间有哪些协作方式?

join wait notify notifyall

await sinal sinalall

### Synchronized可以作用在哪里?

方法 对象 类

### Synchronized本质上是通过什么保证线程安全的?

监视器指令 监视器计数器 ++ -- 可重入锁

### Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?

锁粗化

锁消除

轻量级锁

偏向锁

自适应自旋锁

### Synchronized由什么样的缺陷? Java Lock是怎么弥补这些缺陷的?

只能有一个条件 与Conditional结合 多个条件

无法获取锁状态 try

不可中断 可优先响应中断和超时时间

### Synchronized和Lock的对比，和选择?

公平不公平

JVM JDK

可中断 不可中断

状态 可获取状态

少量同步 大量同步

单一条件 多个条件

指令 CAS

### Synchronized在使用时有何注意事项?

避免对象为空 锁信息存储在对象头

避免死锁

作用域不要太大

能不用就不用 尽量用synchronized

### Synchronized修饰的方法在抛出异常时,会释放锁吗?

会

### 多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?

抢占式

### synchronized是公平锁吗？

不是

### volatile关键字的作用是什么?

保证可见性 有序性 单词读写的原子性

### volatile能保证原子性吗?

只能保证单次读写的原子性

### 32位机器上共享的long和double变量的为什么要用volatile?

高32位和低32位 保证单次读写的原子性

### volatile是如何实现可见性的?

内存屏障

### volatile是如何实现有序性的?

happens-before规则

### 说下volatile的应用场景?

对变量的修改不依赖于当前值

该变量不存在其他变量的可变式中

该变量的状态不依赖于其他内容

双重检查单例模式

```java
public class c{
    private volatile static C c;
    private C(){
        
    }
    public static C get(){
        if(c==null){
            Synchronized(C.class){
                if(c==null){
                	c=new C();
                }
            }
        }
        return c;
    }
}
```



### 所有的final修饰的字段都是编译期常量吗?

不是

### 如何理解private所修饰的方法是隐式的final?

private 修饰的方法不能被子类重写 并且不能被子类调用 对子类不可见 因此不可修改

### 说说final类型的类如何拓展?

采用外观模式

就是将该类作为一个成员 调用方法还调用该类的

### final方法可以被重载吗?

可以被重载

### 父类的final方法能不能够被子类重写?

不能

### 说说基本类型的final域重排序规则?

防止写重排序到构造函数之外

防止读在获取对象之前

### 说说final的原理?

构造方法结束前加入写写屏障

读取数据前加入读读屏障

### JUC框架包含几个部分?

工具、锁、原子类、线程池、集合类

 ### Lock框架和Tools哪些核心的类?

reentrantlock coutdown

### JUC并发集合哪些核心的类?

copyonwiteArrayList

concurrenthashmap

### JUC原子类哪些核心的类?

13个 4类

基本类型

AtomicInteger

AtomicBoolean

AtomicLong

数组类型

AtomicIntegerArray

AtomicLongArray

AtomicReffenceArray

引用类型

AtomicIntegerFeidUpdater

AtomicLongFeidUpdater

AtomicReferenceFeidUpdater

AtomicStampedFeidUpdater

字段类型

AtomicReference

AtomicStampedReference

AtomicMarkableReference

### JUC线程池哪些核心的类?

Executor

ExecutorService

### 线程安全的实现方法有哪些?

互斥阻塞

synchronized reentrantlock

同步非阻塞

CAS 原子类

无同步方案

栈封闭 Thread Local 可重入代码

### 什么是CAS?

CAS是硬件的一个原子指令，比较一个值是否是原来的值 是的话就修改 不是就不修改

### CAS使用示例，结合AtomicInteger给出示例?

```java
AtomicInteger integer=new AtomicInteger(0);
integer.addAndGet(1);
```

### CAS会有哪些问题?

CAS会有ABA、循环开销大、只能保证一个共享变量的原子操作

ABA 先改为了B 又改为了A 认为没改 加版本号 AtomicStampedReference

循环开销大 如果JVM支持pause指令 则会有所提升 避免CPU消耗过大

只能保证一个共享变量的原子操作  使用AtomicReference 包裹起来

### AtomicInteger底层实现?

CAS volatile

### 请阐述你对Unsafe类的理解?

实现内存屏障等功能

### 说说你对Java原子类的理解?

四组 13个

基本类型

AtomicInteger

AtomicLong

AtomicBoolean

数组

AtomicIntegerArray

AtomicLongArray

AtomicReferenceArray

引用类型

AtomicIntegerFeildUpdater

AtomicLongFeildUpdater

AtomicReferenceFeildUpdater

AtomicStampedReferenceFeildUpdater

字段

AtomicStampedReference

AtomicReference

AtomicMarkableReference

### AtomicStampedReference是怎么解决ABA的?

里面除了存放对象以外还存放着一个stamp的自动更新的整数标记 构成一个pair

### 为什么LockSupport也是核心基础类? 

AQS借助Unsafe和LockSupport unlock和lock

### 通过wait/notify实现同步?

wait notify 要在synchronized

### 通过LockSupport的park/unpark实现同步？

随意调用 park阻塞 unpark 释放

### Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点

Thread.sleep() Object.wait()

不释放占有的锁 释放占有的锁

等到之间自动唤醒 等到时间唤醒 或者手动唤醒

必须设置时间 不设置资源

Thread.sleep() Condition.wait()

和wait 一样的 不过Condition 会将锁释放 再调用park 方法

Object.wait() LockSupport.park()

都可以设置时间

释放锁 不释放锁

在synchronized 中调用

异常

无异常

Thread.sleep() LockSupport.park()

都是阻塞

都不释放锁

必须设置时间

可以设置可以不设置 

只能时间到期唤醒

可以手动唤醒

本身是一个本地方法 是调用unsafe中的本地方法

### 如果在wait()之前执行了notify()会怎样?

一直阻塞

### 如果在park()之前执行了unpark()会怎样?

跳过park 方法继续执行

### 什么是AQS? 为什么它是核心?

AQS是实现锁和同步器的框架。它的核心线程访问的资源如果是空闲的就把当前线程直接设置为工作线程，如果是占有就需要一套线程等待阻塞以及被唤醒时锁分配的机制。

这个机制使用的时CLH队列实现的 CLH内部时虚拟的双向队列 里面只存储节点之间的关系

### AQS的核心思想是什么?

当被访问的资源是空闲的时候就将当前线程直接设置为工作线程，如果是占有的就需要一套线程阻塞等待以及被唤醒时锁分配机制，这个机制AQS是用CLH队列实现的，将暂时获取不到的锁的线程加入到队列中。

### AQS有哪些核心的方法?

tryAcquire/tryRelase

tryAcquireShared/tryRelaseShared

### AQS定义什么样的资源获取方式?

独占和共享的

### AQS底层使用了什么样的设计模式?

模板

### 什么是可重入，什么是可重入锁? 它用来解决什么问题?

可重入指的是反复的调用同一个方法不会报错

可重入锁是反复调用同一个被锁的方法，或获取到已有的锁，不会因为前面获取过还没释放而阻塞

### ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗?

内部类

公平锁 非公平锁继承队列 继承AQS

### ReentrantLock是如何实现公平锁的?

fairSync

### ReentrantLock是如何实现非公平锁的?

nonfairsync

### ReentrantLock默认实现的是公平还是非公平锁?

非公平锁

### 为了有了ReentrantLock还需要ReentrantReadWriteLock?

读写分离

### ReentrantReadWriteLock底层实现原理?

五个内部类 公平锁 非公平锁 Sync 读锁 写锁

### ReentrantReadWriteLock底层读写状态如何设计的?

高16位读锁 低16位写锁

### 读锁和写锁的最大数量是多少?

2^16-1

### 本地线程计数器ThreadLocalHoldCounter是用来做什么的?

记录可重入的次数

### 写锁的获取与释放是怎么实现的?

tryAcquire/tryRelease

### 读锁的获取与释放是怎么实现的?

tryAcquireShared/tryReleaseShared

### 什么是锁的升降级?

写锁降级为读锁

读锁升级为写锁

读写锁拒接将读锁升级为写锁 因为很多读锁同时读 如果写锁进行了修改其他读锁不可见 保证数据的可见性

### 为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?

因为HashTable 中对所有的put和remove 都加了synchronized 避免删除时一个在读 那么就会造成下标溢出，造成双重锁并发度为1 concurrentHashMap 并发度为16

### ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题

1.7 是分段锁 数组 链表 

1.8 数组 链表 红黑树 

解决了1.7的高并发问题

### ConcurrentHashMap JDK1.7实现的原理是什么?

分段锁 数组 链表 每个segement 继承ReentrantLock

### ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?

默认是16  并发 数据迁移

### ConcurrentHashMap JDK1.7说说其put的机制?

先找个segement 再找到hash 数组

在放链表尾

### ConcurrentHashMap JDK1.7是如何扩容的?

rehash put前判断是否满了，满了就扩容 扩容为原来的两倍 

### ConcurrentHashMap JDK1.8实现的原理是什么?

数组 链表 红黑树

### ConcurrentHashMap JDK1.8是如何扩容的?

tryPresize 扩容为原来的两倍 数组扩容

### ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?

链表长度为8

### ConcurrentHashMap JDK1.8是如何进行数据迁移的?

transfer 将原来的 tab 数组的元素迁移到新的 nextTab 数组中

### 先说说非并发集合中Fail-fast机制?

modcount 计数器

### CopyOnWriteArrayList的实现原理?

实现原理是基于拷贝的

属性中有一个锁 还有一个Object 数组 反射和CAS

### 弱一致性的迭代器原理是怎么样的?

弱一致性迭代器指的是一个快照，只支持读操作 不支持增删改

### CopyOnWriteArrayList为什么并发安全且性能比Vector好?

Vector 锁了所有的操作 造成了双重锁 大大降低效率

### CopyOnWriteArrayList有何缺陷，说说其应用场景?

内存限制 容易造成oom

不实时性 拷贝需要占用很多时间

适合读多写少 但是也不要用 

### 要想用线程安全的队列有哪些选择?

ConcurrentblockQueue ConcurrentDelayQueue ConcurrentLinkedQueue

### ConcurrentLinkedQueue实现的数据结构?

双向链表 里面头尾 Unsafe 使用CAS来保证线程安全

### ConcurrentLinkedQueue底层原理?

头尾 Unsafe

### ConcurrentLinkedQueue的核心方法有哪些?

offer remove peek poll isEmpty

### 说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计?

插入时如果尾不为空则找到真的尾插入 为空直接插入不移动指针

删除时头为空 找到真正的头删除更新head 不为空直接删除不更新head

### ConcurrentLinkedQueue适合什么样的使用场景?

适合高并发的场景 但是没有blockingQueue用的广泛

### 什么是BlockingDeque? 适合用在什么样的场景?

一个线程生成对象 一个消费对象 生产者消费者模式

如果没有则取阻塞

如果满了则放阻塞

### BlockingQueue大家族有哪些?

LinkedBlockingQueue

### BlockingQueue常用的方法?

take put 阻塞

### BlockingQueue 实现例子?

```java
BlockingQueue queue= new ArrayBlockingQueue();
queue.put("1");
queue.put("2");
queue.take();
queue.take();
```

### 什么是BlockingDeque? 适合用在什么样的场景?

双端队列

适合两端都可以出队和入队

### BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法?

继承关系

### BlockingDeque大家族有哪些?

LinkedBlockingDeque

### BlockingDeque 实现例子?

```java
BlockingDeque<String> deque = new LinkedBlockingDeque<String>();
deque.addFirst("1");
deque.addLast("2");
 
String two = deque.takeLast();
String one = deque.takeFirst();
```

### FutureTask用来解决什么问题的? 为什么会出现?

FutureTask 为Future 提供了基础的实现 用于获取结果 取消任务

### FutureTask类结构关系怎么样的?

callable runnablefuture runnable  future

### FutureTask的线程安全是由什么保证的?

CAS保证

### FutureTask通常会怎么用? 举例说明。

写一个FutureTask 里面放callable 外面线程start

get 阻塞获取结果

### 为什么要有线程池?

减少资源消耗

管理线程

提高响应速度

### Java是实现和管理线程池有哪些方式? 请简单举例如何使用。

Excutor ThreadPoolExcutor

### ThreadPoolExecutor的原理?

一个阻塞任务队列 和一个set 工作线程

当一个线程被加入 则先看看有没有达到核心 没有创建线程执行

否则放入阻塞队列

阻塞队列满了 没有达到最大线程数则创建线程执行

否则拒绝

### ThreadPoolExecutor有哪些核心的配置参数? 请简要说明

核心线程数

最大线程数

空闲时存活时间

存活时间单位单位

阻塞队列

创建线程工厂

拒绝策略

### ThreadPoolExecutor可以创建哪是哪三种线程池呢?

FixedThreadPool 固定线程数 无界队列

SingleThreadPool 只有一个线程 无界队列

cachedThreadPool 无线程 每次创建一个

### 当队列满了并且worker的数量达到maxSize的时候，会怎么样?

执行拒绝策略

### 说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略?

拒绝报错

拒绝直接丢掉

拒绝用当前线程执行

执行 将最前进入的弹出

### 简要说下线程池的任务执行机制?

execute addworker runworker

执行 如果没有到达核心数 添加线程 调用start 其实是在调用runworker方法

任务执行完成后 看看队列里如果还有任务就执行 没有 看看超过核心 销毁 否则阻塞等待有任务

### 线程池中任务是如何提交的?

submit 提交后 execute 然后future执行 主线程调用get 方法等待 执行完成后拿到结果

### 线程池中任务是如何关闭的?

shutdown  将所有线程设置Stop中断没有在运行的线程

shutdownNow 将所有线程设置为stop 中止所有线程

### 在配置线程池的时候需要考虑哪些配置因素?

io密集还是CPU密集

io 则为2n

cpu n+1

### 如何监控线程池的状态?

核心线程数

最大线程数

活跃线程数

执行的任务

完成的任务

### 为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢?

因为不理解线程池的真正运行方式 里面调用的是ThreadPoolExecutor

推荐使用工具包 或者依赖注入 ThreadPoolTaskExcutor

### ScheduledThreadPoolExecutor要解决什么样的问题?

解决周期性的执行某些任务

### ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性?

周期性的执行任务

专门存储任务 ScheduledFutureTask

专门存储队列DelayedWorkQueue

run-after-shutdown有一个配置 线程中止是还继续不继续执行周期任务

### ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类?

继承ThreadPoolExecutor

ScheduledFutureTask  ScheduledFuture 

DelayedWorkQueue blockingQueue

### ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类?

shutdown 设置为stop 空闲的停止 选择是否还继续周期性任务

shutdownnow 立即停止

### ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么?

scheduleAtFixedRate  按照开始时间 每个间隔一定的时间运行 正数

scheduleWithFixedDelay 按照上一个任务运行的结束时间  负数

### 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor?

ScheduledThreadPoolExecutor 无界对象 最大线程数失效

### Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor?

ScheduledThreadPoolExecutor 指定核心线程数

singleScheduledThreadPoolExecutor 只有一个线程 异常 再开一个新的

### Fork/Join主要用来解决什么样的问题?

并行处理的问题 充分合理的利用CPU资源

### Fork/Join框架是在哪个JDK版本中引入的?

1.7

### Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?

线程池 工作线程 任务

### ForkJoinPool类继承关系?

工作队列

默认工厂

有系统安全的工厂

### ForkJoinTask抽象类继承关系?

实现Future 里面五个内部类

四个是进行runnable callable 转换为ForkjoinTask

一个是异常链表 

### 整个Fork/Join 框架的执行流程/运行机制是怎么样的?

外部任务提交 内部任务提交 运行 获取结果

### 具体阐述Fork/Join的分治思想和work-stealing 实现方式?

分治思想就是将大任务拆分为一个个小任务

work-stealing 

就是每个线程都有自己的阻塞队列，自己消费完后 可以去其他人的队列中poll 任务 自己只支持push pop

### 有哪些JDK源码中使用了Fork/Join思想?

并行排序 数组

### 如何使用Executors工具类创建ForkJoinPool?

newWorkStealingPool() 指定并发级别和不指定默认为jvm可用的处理器个数

### 写一个例子: 用ForkJoin方式实现1+2+3+...+100000?

```java
public class Test {
	static final class SumTask extends RecursiveTask<Integer> {
		private static final long serialVersionUID = 1L;
		
		final int start; //开始计算的数
		final int end; //最后计算的数
		
		SumTask(int start, int end) {
			this.start = start;
			this.end = end;
		}

		@Override
		protected Integer compute() {
			//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果
			if(end - start < 1000) {
				System.out.println(Thread.currentThread().getName() + " 开始执行: " + start + "-" + end);
				int sum = 0;
				for(int i = start; i <= end; i++)
					sum += i;
				return sum;
			}
			//如果计算量大于1000，那么拆分为两个任务
			SumTask task1 = new SumTask(start, (start + end) / 2);
			SumTask task2 = new SumTask((start + end) / 2 + 1, end);
			//执行任务
			task1.fork();
			task2.fork();
			//获取任务执行的结果
			return task1.join() + task2.join();
		}
	}
	
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ForkJoinPool pool = new ForkJoinPool();
		ForkJoinTask<Integer> task = new SumTask(1, 10000);
		pool.submit(task);
		System.out.println(task.get());
	}
}
```

### Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。

fork 正着来 join 倒着来

### 什么是CountDownLatch?

实现多个线程的并发同步器

### CountDownLatch底层实现原理?

底层AQS 两个CLH虚拟双向队列

### CountDownLatch一次可以唤醒几个任务?

n个

### CountDownLatch有哪些主要方法?

await countDown

### 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束?

```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定  Count 值为0时当前线程继续执行，
 */
public class T3 {

   volatile List list = new ArrayList();

    public void add(int i){
        list.add(i);
    }

    public int getSize(){
        return list.size();
    }


    public static void main(String[] args) {
        T3 t = new T3();
        CountDownLatch countDownLatch = new CountDownLatch(1);

        new Thread(() -> {
            System.out.println("t2 start");
           if(t.getSize() != 5){
               try {
                   countDownLatch.await();
                   System.out.println("t2 end");
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        },"t2").start();

        new Thread(()->{
            System.out.println("t1 start");
           for (int i = 0;i<9;i++){
               t.add(i);
               System.out.println("add"+ i);
               if(t.getSize() == 5){
                   System.out.println("countdown is open");
                   countDownLatch.countDown();
               }
           }
            System.out.println("t1 end");
        },"t1").start();
    }

}
```

### 什么是CyclicBarrier?

栅栏 到达一个同步点

### CountDownLatch和CyclicBarrier对比?

只能使用一次 重复使用

### 什么是Semaphore?

信号量 允许多个线程同时访问一个共享资源

### Semaphore内部原理?

AQS 和ReentrantLock锁一样

公平 非公平锁 sync 

### Semaphore常用方法有哪些? 如何实现线程同步和互斥的?

acquire release

### 单独使用Semaphore是不会使用到AQS的条件队列?

只有await操作会进入条件队列 其他都在同步队列，只是当前线程被park

### Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?

阻塞

### Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?

阻塞

### Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?

可以

### Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?

可以

### Phaser主要用来解决什么问题?

动态的注册任务

### Phaser与CyclicBarrier和CountDownLatch的区别是什么?

支持任务动态调整

### Phaser运行机制是什么样的?

注册 同步 分层 中止 状态监控

### 给一个Phaser使用的示例? 模拟了100米赛跑，10名选手，只等裁判一声令下。当所有人都到达终点时，比赛结束。

```java
public class Match {

    // 模拟了100米赛跑，10名选手，只等裁判一声令下。当所有人都到达终点时，比赛结束。
    public static void main(String[] args) throws InterruptedException {

        final Phaser phaser=new Phaser(1) ;
        // 十名选手
        for (int index = 0; index < 10; index++) {
            phaser.register();
            new Thread(new player(phaser),"player"+index).start();
        }
        System.out.println("Game Start");
        //注销当前线程,比赛开始
        phaser.arriveAndDeregister();
        //是否非终止态一直等待
        while(!phaser.isTerminated()){
        }
        System.out.println("Game Over");
    }
}
class player implements Runnable{

    private  final Phaser phaser ;

    player(Phaser phaser){
        this.phaser=phaser;
    }
    @Override
    public void run() {
        try {
            // 第一阶段——等待创建好所有线程再开始
            phaser.arriveAndAwaitAdvance();

            // 第二阶段——等待所有选手准备好再开始
            Thread.sleep((long) (Math.random() * 10000));
            System.out.println(Thread.currentThread().getName() + " ready");
            phaser.arriveAndAwaitAdvance();

            // 第三阶段——等待所有选手准备好到达，到达后，该线程从phaser中注销，不在进行下面的阶段。
            Thread.sleep((long) (Math.random() * 10000));
            System.out.println(Thread.currentThread().getName() + " arrived");
            phaser.arriveAndDeregister();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### Exchanger主要解决什么问题?

不同线程之间数据交换问题

### 对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式?

SynchronousQueue只是给 Exchanger是A给B B给A 所以是双向的

### Exchanger在不同的JDK版本中实现有什么差别?

在JDK5中Exchanger被设计成一个容量为1的容器，存放一个等待线程，直到有另外线程到来就会发生数据交换，然后清空容器，等到下一个到来的线程。

1.6 加入分段 加入了槽 提高并发能力

### Exchanger实现举例 来一个非常经典的并发问题：你有相同的数据buffer，一个或多个数据生产者，和一个或多个数据消费者。只是Exchange类只能同步2个线程，所以你只能在你的生产者和消费者问题中只有一个生产者和一个消费者时使用这个类。

```java
public class Test {
    static class Producer extends Thread {
        private Exchanger<Integer> exchanger;
        private static int data = 0;
        Producer(String name, Exchanger<Integer> exchanger) {
            super("Producer-" + name);
            this.exchanger = exchanger;
        }

        @Override
        public void run() {
            for (int i=1; i<5; i++) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                    data = i;
                    System.out.println(getName()+" 交换前:" + data);
                    data = exchanger.exchange(data);
                    System.out.println(getName()+" 交换后:" + data);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static class Consumer extends Thread {
        private Exchanger<Integer> exchanger;
        private static int data = 0;
        Consumer(String name, Exchanger<Integer> exchanger) {
            super("Consumer-" + name);
            this.exchanger = exchanger;
        }

        @Override
        public void run() {
            while (true) {
                data = 0;
                System.out.println(getName()+" 交换前:" + data);
                try {
                    TimeUnit.SECONDS.sleep(1);
                    data = exchanger.exchange(data);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(getName()+" 交换后:" + data);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Exchanger<Integer> exchanger = new Exchanger<Integer>();
        new Producer("", exchanger).start();
        new Consumer("", exchanger).start();
        TimeUnit.SECONDS.sleep(7);
        System.exit(-1);
    }
}
```

### 什么是ThreadLocal? 用来解决什么问题的?

通过线程隔离来解决线程安全问题

### 说说你对ThreadLocal的理解

就是让每个线程中的变量都存储在ThreadLocal 根据线程获取

### ThreadLocal是如何实现线程隔离的?

ThreadLocalMap

### 为什么ThreadLocal会造成内存泄露? 如何解决

每一个Thread线程都维护了一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal 实例本身，value 是真正需 要存储的Object，也就是说ThreadLocal本身并不存储值，它只是作为一个 key来让线程从ThreadLocalMap获取value。ThreadLocalMap是使用ThreadLocal的弱引用作为Key的，弱引用的对象在GC 时会被回收。 当把 threadlocal 变量置为 null 以后，没有任何强引用指向 threadlocal 实例，所以 threadlocal将会被gc回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前 线程再迟迟不结束的话，这些key为null的Entry的 value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value，而这块value永远不会被访问到了，所以存在着内存泄露。


### 还有哪些使用ThreadLocal的应用场景?

- 每个线程维护了一个“序列号”

- 看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:

```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
 
public class DateUtils {
    public static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>(){
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd");
        }
    };
}
```











### 如何从数据传输方式理解IO流？

数据传输分为字节流和字符流 Stream、Reader Writer 图片二进制文件 字节流 文本文件 字符流

### 如何从数据操作上理解IO流？

文件 管道 缓冲区 流的 输入输出的 转换的 数组的 基本数据类型的 对象序列化反序列化的

### Java IO设计上使用了什么设计模式？

使用装饰器模式 给被装饰者添加装饰 增加功能



### 什么是阻塞？什么是同步？

阻塞是针对程序级别的 指的是在io 资源没有准备好时，程序怎么做 阻塞就是等待 非阻塞就是先获取一个状态 等准备好了再去拷贝资源

同步是针对操作系统的 指的是io 资源没有准备好时 同步是什么也不返回 非同步时 不管准备好没好都返回，等到准备好时进行拷贝

### 什么是Linux的IO模型？

网络数据传输时socket 进行的 socket在linux 被认为是流，io流传输的过程是先从磁盘拷贝到操作系统内核，再从操作系统内核拷贝到应用进程。

一个io读 会先等到准备好 准备好后拷贝到应用进程

网络上的 是先等接收完成后 拷贝到操作系统内核 再从操作系统内核拷贝到应用进程

五大io模型

同步非阻塞

同步阻塞

多路复用

信号驱动

异步

### 什么是同步阻塞IO？

同步阻塞是指 在io资源没有准备好时 应用线程一直等待 直到准备好进行数据拷贝

### 什么是同步非阻塞IO？

同步非阻塞是指在io 资源没有准备好时 先返回一个失败状态 应用线程可以做其他事 不过要一直轮询问io有没有准备好 准备好了将数据复制到缓冲区

### 什么是多路复用IO？

多路复用其实是让一个线程可以完成多个io操作

一个io 可能是由多个任务组成的，拆分成多个任务。调用epoll 在一个资源准备好时就进行复制 不用等待所有的都准备好

### 有哪些多路复用IO？

select 

poll

epoll

kqueue

### 什么是信号驱动IO？

信号驱动指的是 资源还没准备好 返回一个状态 然后应用线程执行其他事 等资源准备好了 发一个信号给应用线程，应用线程拿到信号就去复制数据

### 什么是异步IO？

异步io 指的是不管资源有没有准备好都直接返回 等到资源准备好了就直接复制给应用程序

### 什么是Reactor模型？

普通的io 模型 每个都直接连接一个hander

Reactor 模型包含三个组件 Reactor Selector Handler

Reactor 处理请求 并转发 dispator

Acceptor 新建立的连接 转发到handler

handler 处理请求 

单Reactor单线程

先去Reactor dispatch 转发 如果是新建的转发到Acceptor

Acceptor 处理新建 转发到handler

不是的话 找对应handler 

handler 进行处理

单Reactor 多线程

将handler 池化

多Reactor

主从 主转发 从处理

### 什么是Java NIO？

java NIO 包括selector channel buffer 区别于普通的io 普通的是根据字节nio 是操作缓存区 基于事件驱动的多路复用

每一个channel 都要注册到selector 上

### 传统的IO存在什么问题？为什么引入零拷贝的？

传统的io 执行通过read wirte 需要先从磁盘通过DMA 拷贝到内核 再从内核到应用进程 再从应用进程到内核 再从内核DMA到磁盘 四次拷贝 四次上下文切换 上下文切换浪费时间 提高传输性能 减少上下文切换和拷贝次数

### mmap + write怎么实现的零拷贝？

mmap 通过内存共享 将内核内存共享给用户空间 三次拷贝 四次上下文切换 一次cpu 拷贝

### sendfile怎么实现的零拷贝？

使用sendfile 命令 里面cpu 拷贝 三次拷贝 两次上下文切换

看网卡支持scatter-gather 如果支持 可以通过sg-DMA 进行拷贝 记录描述符和操作长度

两次拷贝 两次上下文切换 

所谓零拷贝 值得就是不使用cpu 拷贝 全部通过DMA进行拷贝 与传统io 相比我们减少了2次上下文切换和2次cpu拷贝

### 类加载的生命周期？

加载 验证 准备 解析 初始化 使用 卸载

加载二进制文件

验证是一个合法的类

准备 静态变量初始化默认值找空间

解析 符号引用转换为直接引用

初始化 对静态变量赋值 对象进行赋值 空间

使用 使用堆中的对象

卸载 就是对象消亡

### 类加载器的层次?

主启动类加载器 lib xBootStrap 配置的

扩展类加载器 ext

应用类加载器 类路径下

自定义加载器

### Class.forName()和ClassLoader.loadClass()区别?

class.forName() jvm外 执行静态代码块构造对象

classLoader.loadClass() jvm中 不执行静态代码块 等newInstence时再执行静态方法

class.from()可以配置 执不执行静态代码块

### JVM有哪些类加载机制？

全盘托管 与该类相关的类都由加载该类的加载器 加载

父类委托 委托给父类进行加载

缓存机制 加入缓存 有则不加载

双亲委派 先给父加载 父成功则不再子加载 一直到子如果还没有加载成功就报classnotFound异常

### 说说JVM内存整体的结构？线程私有还是共享的？

方法区 堆 堆外内存 虚拟机栈 本地方法栈 程序计数器

私有 虚拟机栈 本地方法栈 程序计数器

共享 堆 堆外内存 方法区

### 什么是程序计数器（线程私有）？

程序计数器中存储着下一条指令的地址，执行引擎加载下一条指令。因为线程每次中断和恢复需要知道本次执行到哪里了，所以程序计数器是私有的。

### 什么是虚拟机栈（线程私有）？

虚拟机栈管理着java 方法的调用 每个线程私有 内部是一个个栈帧生命周期和线程一样

栈帧的内部结构

局部变量表 操作数栈 动态链接 方法返回地址 返回信息 其他信息

特点

方法调用入栈 调用完成出栈

访问速度快 仅次于程序计数器

栈不存在垃圾回收

通过xss 调整 最大内存

有什么异常

如果是固定内存 超出 包stackover

如果是动态的 不能再分配 报oom

### Java虚拟机栈如何进行方法计算的？

局部变量表存值取值 操作数栈 计算

 ### 什么是本地方法栈（线程私有）？

本地方法 指的是java 内调用的非java方法

本地方法栈就是用来java本地方法调用的

### 什么是方法区（线程共享）？

方法区是Java中的概念，存储常量池 静态成员变量 jit编译期编译后的代码缓存 类信息 永久代和元空间是方法区的落地实现

堆 栈 方法区交互关系

堆中 放对象

栈中 放变量 对象引用

方法区中 放类信息

### 永久代和元空间内存使用上的差异?

永久代使用的是固定内存 有固定大小

元空间内存 取决于机器 使用直接内存

jdk 1.7起 字符串常量池 静态变量 放到堆中 

符号引用没有存放在元空间

### 堆区内存是怎么细分的？

分为老年代 和 新生代 新生代分为ede区 幸存者0 1区

### JVM中对象在堆中的生命周期?

先来到e区 e区满后 发生minor gc 将对象方法幸存者区 两个幸存者相互拷贝 总有一个是空的

到达一定年龄后进入老年代 老年代满后发生major gc

### JVM中对象的分配过程?

先分配到e区 大对象直接分配到老年代，e区满后 发生minor gc 将对象方法幸存者区 两个幸存者相互拷贝 总有一个是空的

到达一定年龄后进入老年代 老年代满后发生major gc

### 什么是 TLAB （Thread Local Allocation Buffer）?

TLAB其实是e区为每个线程提供的缓存。多个线程同时分配内存，使用TLAB提高吞吐量，避免非线程安全 快速分配策略

### 为什么要有 TLAB ?

因为堆是共享空间 所有线程均可以访问

为了保证线程安全  避免加锁抢占资源

分配失败 尝试加锁保证原子性

### 如何判断一个对象是否可以回收？

引用标记算法

引用一次 标记计数器+1 引用失效 -1 为0可以回收

可达性分析

从GC root 往下可以找到 说明被引用 找不到可以被回收

哪些可以作为Gc root 对象

虚拟机栈中引用的对象 本地方法栈引用的对象 方法区中静态属性引用的对象 方法区中常量变量引用的对象

### 对象有哪些引用类型？

强引用类型 new  不会被回收

软引用类型 soft 内存不足时回收 

弱引用类型 weak 下一次GC时回收

虚引用类型 pha 回收收到通知

### 有哪些基本的垃圾回收算法？

标记清除

内存碎片

标记整理 先标记然后在整理 再清理

标记复制 两块区域 每次从一块区域存活的复制到另一块区域 清除另一块区域

分代收集 老年代和新生代 每一代有各自的回收算法

### 分代收集算法和分区收集算法区别？

分代收集算法 分为老年代和新生代 新生代使用标记复制算法 因为新生代对象比较小 复制不会占用太大 老年代使用标记清除或者整理算法

cms

per-new

分区是将整堆划分为一个个小的区域 每个小的区域独立回收和使用

G1

ZGC

### 什么是Minor GC、Major GC、Full GC?

Minor Gc 回收新生代

MajorGc 回收老年代

混合gc 回收新生代和部分老年代

FullGc 回收整个堆和方法区

### 说说JVM内存分配策略？

e区优先

大对象直接进入老年代

年领大的进入老年代 默认15

动态年龄策略 如果超过某个年龄的占到幸存者区超过一半 进入老年代

空间分配担保 最大可用内存大于幸存的 则可以进行minor gc 否则 看担保参数是否允许失败 如果允许 则用历次minor gc 往老年代转移的对象大小的平均数与最大可用内存 比较 小于可以 大于fullgc

### 什么情况下会触发Full GC？

手动调用 system.gc

方法区满了

老年代内存不足

空间担保失败

并发迁移失败 cms 回收器 并发标记期间 同时有对象放入老年代

### Hotspot中有哪些垃圾回收器？

新生代标记复制 老年代 标记整理

串行回收器

per-new 并发 与cms 合用

并行回收器

串行老年代回收器

并行老年代回收器

新生代标记复制 老年代标记清除

cms

初始标记

并发标记

重新标记

并发清除

碎片 暂停时间长

分区 标记整理和复制

G1

初始标记

并发标记

最终标记

筛选回收 缩短停止时间 可预测的停顿

ZGC  

### JDK自带的定位问题的工具？

jps 打印线程

jinfo 参数信息

jstack 线程信息

jmap 生成dump 文件

jstat 运行信息

###  Java 8 特性

lambal 表达式

重复注解

类型注解

接口中有默认方法

Optional 判空

stream

### Java 9+ 特性

三年发布tls 版本

g1

zgc

record

swith 表达式简化



### 什么是事务？事务基本特性ACID？

事务是一组满足ACID的操作

A 原子性 要么全成功要么全失败

C 一致性 从一个一致性状态转换到另一个一致性状态

I 隔离性 一个事务没有提交 其他事务就看不见

D 持久性 一旦事务提交 被永久保存到数据库中

### 数据库中并发一致性问题？

丢失修改 一个线程修改给另一个线程覆盖了

脏读 读取到一个线程还没有提交的数据

不可重复读 读取时一个线程读取到两个不同的值

幻读 范围查询 一个线程读取到不一样大小的数据量

### 事务的隔离等级？

读未提交 读到未提交的值

读已提交 读到的值都是已提交的 解决脏读问题

可重复读 一个线程重复读结果一致 解决不可重复读

串行化 解决幻读问题

### ACID靠什么保证的呢？

A 靠undo_log

C 业务

I MVCC

D redo_log

### SQL 优化的实践经验？

避免使用Select * 

避免在where 中使用or

避免隐式转换 是什么类型就用什么类型

避免where 中用in

使用索引

索引数量不能超过6个

### Buffer Pool、Redo Log Buffer 和undo log、redo log、bin log 概念以及关系？

buffer pool mysql 缓存 增删改查在这里执行

undo_log 操作前的数据

redo_log 操作后的数据

bin_log 操作日志

### 从准备更新一条数据到事务的提交的流程描述？

先去bufferpool 中找 有更新

没有查数据库 查到写入buffer pool 同时写入undo_log

在buffer pool 进行修改 写入redolog Buffer

提交后 写入redo_log 同时在bin_log中记录操作

将bin_log 的文件名和位置 记录到redo_log中 并加上commit 标识

### 能说下myisam 和 innodb的区别吗？

myisam 不支持行锁 事务 外键 可以全文索引、压缩、空间索引 索引和数据分开存储

innode 支持行锁 事务 外键 索引和数据在一起存储 并发利用MVCC

### 说下MySQL的索引有哪些吧？

B+

Hash

全文索引

地理空间索引





唯一

主键

联合

普通

全文

覆盖

### 什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？

B+树是在B树的基础上 在叶子节点之间添加了顺序指针 叶子节点是有顺序的 从左到右非递增排序

减少IO操作 查找效率高

加载页时 预先加载 因为是从小到大排列的

范围查找

### 那你知道什么是覆盖索引和回表吗？

覆盖索引指的索引包含或就是查找的字段，不用回表

否则 先查出来id 再根据id 进行回表查数据

### 什么是MVCC？ 说说MySQL实现MVCC的原理？

MVCC是多版本并发控制

实现原理是隐藏字段+undo_log+readView

隐藏字段中包含事务id 主键id 回滚指针

undo_log 中回滚指针指向上一个事务id 构成链表

readView 中记录了本次事务的id列表，当列表中最小值大于事务id 说明可见 否则不可见

不可重复读是每次都生成一个readView

可重复读是共用一个readView

### MySQL 锁的类型有哪些呢？

表锁 

意向共享锁

意向排他锁

行锁

共享锁 排他锁

### 你们数据量级多大？分库分表怎么做的？

根据业务进行分库

不相关的字段 垂直拆分 表

数据量大的话 对表进行水平拆分

### 那分表后的ID怎么保证唯一性的呢？

不同的数据库进行初始值和自增长

分布式id 雪花算法

业务上的唯一值 比如订单号

### 分表后非sharding_key的查询怎么处理呢？

做一个map 映射 先查询再查询

将该字段值后几位拼上sharding_key

### MySQL主从复制？

bin_log 记录的操作日志 通过i/o加载到从服务器 从服务器开启线程 重放这些操作

### MySQL主从的延迟怎么解决呢？

磁盘等 尽量一样 选用好的

高一致性的 强制直接读主

### MySQL读写分离方案?

主库和从库 主库负责读写 从库负责读 一般还有一个代理服务器 选择从哪个服务器读 或者sharding-jdbc

### 什么是MongoDB？为什么使用MongoDB？

MongoDB是面向文档的Nosql数据库 适合大量数据存储

面向文档 不存储关系型数据格式 存储更加灵活 适合业务场景

支持索引 查询效率高

临时查询 支持字段 范围 正则表达式 查询

复制 副本集

负载均衡 分片

### MongoDB与RDBMS区别？有哪些术语？

数据库 数据库

表 collections

行 doucument

列 字段

索引 索引

主键 主键

联立 不支持

### MongoDB聚合的管道方式？

就是将group order 操作管道化 上一个操作的结果可以作为下一个操作的输入 操作可以相同

arrge

### MongoDB聚合的Map Reduce方式？

先map 在 reduce

 ### Spring Data 和MongoDB集成？

mongodb-driver

springdata-mongo 需要自己实现配置

springdata-mongo-start 使用spring autoconfig装配

mongotemplate MongoRespository

### MongoDB 有哪几种存储引擎？

wiredTiger(3.2后默认) MMAPV1 In memory

### 谈谈你对MongoDB WT存储引擎的理解？

WT 搜索引擎是插件式搜索引擎用于服务端和存储引擎的解耦

B-tree +page

有三类节点 root page inter page leafPage

leafpage 存储真正的数据 其他都存储 指向leaf的指针

最小单位是page

为什么是Page？

page是加载到缓存中的单位，操作过程中page 变大 会进行拆分 所有操作都是围绕page 进行的

什么是checkpoint

checkpoint 相当于是日志 记录了上次checkpoint 之后的数据 数据的更改持久化到数据文件中保证数据一致性，发生故障时每次重启缩短数据恢复的时间

checkpoint 中包含 rootpage 三个指向磁盘信息的page列表 文件的大小

如何理解wt事务机制

靠MVCC 快照 和undo_log 实现

如何理解WT的缓存淘汰机制

多段局部扫描和淘汰算法  页面置换算法缓冲区

一个线程不断地扫描每个b-tree 如果发现淘汰加入lru队列中，队列满了会记录当前b-tree对象和位置 按照淘汰优先级从lru队列中淘汰 是一个不断往复的过程

page是基本单位 因为数据都是以page block存储的

### MongoDB为什么要引入复制集？有哪些成员？

为了保证MongoDB的高可用，避免单个节点发生故障后，造成整个服务不可用

有主节点 提供读写

优先级0节点 选举优先级为0

隐藏节点 不提供读写指备份

延迟节点 延迟一段时间 中间有错误进行数据恢复

从节点 主节点发生故障 选举为主节点

仲裁节点 参与选举 不会成为主

### MongoDB复制集常见部署架构？

尽量保证奇数个

三个节点 一个数据中心

一主两从

一主一从一仲裁

五个节点 三个数据中心



### MongoDB复制集是如何保证数据高可用的？

选举机制

故障期间的回滚

选举机制 超过N/2+1 同意选择 否则不提供写服务 选不出主

主节点宕机 重新加入到副本集时，如果当时宕机前有些数据写入了 但现在的主节点上没有 就会进行回滚

什么情况下触发选举机制

副本集初始化时

有节点加入副本集

副本集超时失联

对复制集进行维护时

### MongoDB复制集如何同步数据？

第一种是全量复制

在新的节点刚加入时 则会将主节点数据全部同步到副本集 全量复制

手动调用 新加入的加入失败 重新加入时

增量复制

已经在复制集的节点 当主节点进行写入后 从节点从主节点同步该部分操作日志 然后在从节点重放 

### MongoDB为什么要引入分片？

在高并发的场景下，单数据库很容易造成磁盘空间不足，cpu 很快消耗完了

因此为了得到更大的空间需要进行垂直拆分或者水平拆分

垂直拆分 增大服务器cpu和存储

分片时水平拆分的一种 将数据集分布到不同的服务器

分片设计思想

使用分片减少每个分片的需要处理的请求梳理，通过水平扩展集群可以提高自己的存储能力和吞吐量

分片目的

扩大内存

提高读取能力

高可用

### MongoDB分片集群的结构？

mongos 路由

shard 分片

config server配置服务

### MongoDB分片的内部是如何管理数据的呢？

拆分

平衡

每个分片的最小单位是 chunk chunk 大小可以配置默认是64MB 每个chunk 过大则会自动拆分为小的chunk

如果某个分片下的chunk 数量多 也会自动迁移到其他分片中

### MongoDB 中Collection的数据是根据什么进行分片的呢？

一种是hash 分片 相邻的不一定挨着

范围分片 造成某个为空

先范围再hash

### MongoDB如何做备份恢复？

导出和导入命令 export import json 和 bson bson 二进制 小 不利于读 json 利于读 但是信息不全 用户信息都没有

### MongoDB如何设计文档模型？

多态模式

属性模式

桶模式

### MongoDB如何进行性能优化？

开启慢查询日志

explain 分析

### ElasticSearch是什么？基于Lucene的，那么为什么不是直接使用Lucene呢？

Lucene 是当下最先进，高性能，全功能的搜索引擎库，ElasticSearch是java 编写的，底层是基于Lucene的索引和搜索，简化了Lucene的复杂性，提供一套简单的Restful api

ElasticSearch 不仅仅是lucene,不仅仅只是全文搜索引擎。

ElasticSearch是分布式实时文档存储，可以对每个字段进行索引和搜索，可以存储关系型数据或者非关系数据

ElasricSearch是分布式实时分析搜索引擎

ElasticSearch 支持上百个节点扩展 支持PB级别的数据

和数据库对比

数据库 index

表 type

行 doucument

列 feild

索引 倒排索引

主键 ——id

crud get update delete

表结构 mapping

### ELK 技术栈的常见应用场景？

日志收集

增加数据源和使用MQ 收集

指标收集 APM性能监控

### ES中索引模板是什么？

ES索引模板分为组件模板和索引模板

组件模板是一个构建集，对索引进行设置、别名、映射 不能直接作用于索引

索引模板 可以包含多个组件模板也可以直接对索引进行设置、别名、映射 直接作用于索引

创建前先创建模板 创建索引时 模板作为索引的基础

### ES中索引的生命周期管理？

由于ES中存储的近期数据或者历史常用数据才是有价值的 被称为热数据，而历史其他数据不常用是冷数据但是数据量过大影响ES的性能

所以在6.6引入索引生命周期对索引进行管理

Hot 读写

warm 多读不写

cold 少读不写

delete 安全删除

### ES查询和聚合的有哪些方式？

DSL

ESL

SQL

### ES查询中query和filter的区别？

query 返回分数 filter 只返回查询结果

### ES查询中match和term的区别？

match 基于文本的检索 term 基于词项进行检索

### ES查询中should和must的区别？

should 包含一个条件即可

must 必须全部满足

### ES查询中match，match_phrase和match_phrase_prefix有什么区别？

match 匹配文本

match_phrase 匹配连续文本

match_phrase_prefix 作为前缀匹配

### ES查询中什么是复合查询？有哪些复合查询方式？

bool 

提高查询

固定分数

dis_max 最大分数

自定义函数

### ES聚合中的Bucket聚合有哪些？如何理解？

就是一些过滤操作

### ES聚合中的Metric聚合有哪些？如何理解？

单值 多值 最大最小 百分比

### ES聚合中的管道聚合有哪些？如何理解？

把聚合操作管道化上一个结果作为下一个输入

### 如何理解ES的结构和底层实现？

每个index有多个节点，每个节点是一个实例，

每个实例有多个分片

每个分片 底层使用的Lucene的倒排索引

每个Lucene有多个segement(段文件)，每个段文件中是一个doc 文档。

commit points 中包含所有的段文件

底层和数据文件

tip 词典索引

tim 指向倒排表的指针

doc 倒排表

列式存储

docValues

dvm docValues 元信息

dvd docValues 值

行式存储

正向文件

fnm 文件feild元信息

fdx 指向文档的索引

fdt 文档值

tip->tim->doc->dvd->fdx->fdt

### ES内部读取文档是怎样的？如何实现的？

主分片或副本分片检索文档的步骤顺序

主节点获取请求后 看是在哪个分片 然后从分片进行读取

协调节点会让每个分片负载均衡

读取文档的两阶段查询

访问协调节点

协调节点向每个分片请求数据——id 放到优先队列里

返回给协调节点 协调节点在优先队列里 拿到要访问的id 

再去分片中获取真实数据

### ES内部索引文档是怎样的？如何实现的？

分为单个和整体

单个文档的话就是

请求节点 确定分片后 在主分片写入后 所有的副本分片同步 同步完成后 通知协调节点 协调节点返回给客户端成功

整体

协调节点确定分片

分片拿到协调节点的请求后 先写入memery cache 然后每隔一秒刷新到FileSystem cache 称为refresh

FileSystem cache中的可以被查询到 

过程中可能会丢失 通过translog 保证 每次写入memery 都会写入translog 

然后写入磁盘 缓存清空 translog 删除 开始一个新的translog

### ES底层数据持久化的过程？

写 refresh flush merge

先写入到内存缓存中  同时写入translog

然后每隔1s 刷新到系统文件缓存上 此时可读 所以是准实时性

写入磁盘后 清空缓存 同时删除translog 开始一个新的translog flush

把小的段合并为大的段 merge

### ES遇到什么性能问题，如何优化的？

cpu 选用多核的

硬盘选用SSD 禁止分区 一半留给es

设置refresh 时间 translog 大小 批量提交

查询 慢查询定位



### BST

```java
package com.jhj.algorithm.tree;

public class BST {
    private BSTNode root;

    public class BSTNode{
        int key;
        BSTNode left;
        BSTNode right;
        BSTNode parent;
        public BSTNode(int key,BSTNode parent,BSTNode left,BSTNode right){
            this.key=key;
            this.left=left;
            this.right=right;
            this.parent=parent;
        }
    }
    //前序遍历
    private void preOrder(BSTNode root){
        if (root!=null){
            System.out.println(root.key);
            preOrder(root.left);
            preOrder(root.right);
        }
    }
    public void preOrder(){
        preOrder(root);
    }

    //中序遍历
    private void midOrder(BSTNode root){
        if(root!=null){
            midOrder(root.left);
            System.out.println(root.key);
            midOrder(root.right);
        }
    }
    public void midOrder(){
        midOrder(root);
    }
    //后序遍历
    private void postOder(BSTNode root){
        if(root!=null){
            preOrder(root.left);
            preOrder(root.right);
            System.out.println(root.key);
        }
    }
    public void postOrder(){
        postOder(root);
    }

    //查找
    private BSTNode find(BSTNode root,int key){
        if(root==null){
            return root;
        }
        if(root.key>key){
            return find(root.left,key);
        }else if(root.key<key){
            return find(root.right,key);
        }else{
            return root;
        }
    }
    public BSTNode find(int key){
        return find(root,key);
    }
    //最大
    private BSTNode max(BSTNode root){
        if(root==null){
            return null;
        }
        while (root.right!=null){
            root=root.right;
        }
        return root;
    }
    public int max(){
        BSTNode max = max(root);
        return max==null?null:max.key;
    }

    //最小
    private BSTNode min(BSTNode root){
        if(root==null){
            return root;
        }
        while (root.left!=null){
            root=root.left;
        }
        return root;
    }
    public int min(){
        BSTNode min = min(root);
        return min==null?null:min.key;
    }
    //前驱节点
    //如果左子数不为空 则为左子树最大的
    //如果左子树为空 该节点为父的右子树 则为父节点
    //如果左子树为空 该节点为父的左子树 则为最进的父节点 且父节点有右子树
    // 中
    //   右
    //  左   中小于左
    public BSTNode predecessor(BSTNode root){
        if(root.left!=null)
            return max(root.left);
        BSTNode y=root.parent;
        while (y!=null&&(root==y.left)){
            root=y;
            y=y.parent;
        }
        return y;
    }

    //后继
    //有 右子树 右子树最小值
    //为父的左子树 为父
    //为父的右子树 该节点为父的右子树 且父有左子树
    //   左
    // 中
    //  右
    public BSTNode successor(BSTNode root){
        if(root.right!=null){
            return min(root.right);
        }
        BSTNode y = root.parent;
        while (y!=null&&(root==y.right)){
            root=y;
            y=y.parent;
        }
        return y;
    }
    //该插入的位置一定是子节点 所以找到该插入的位置 然后把z 插入进去 如果树为空则跟节点设为它
    private void insert(BST tree,BSTNode z){
        //找到的位置
        BSTNode y=null;
        BSTNode root=tree.root;
        while (root!=null){
            y=root;
            if(z.key< root.key){
                root=root.left;
            }else{
                root=root.right;
            }
        }
        z.parent=y;
        //如果y是null说明树是空的
        if(y==null){
            tree.root=z;
        }else {
            if(z.key< y.key){
                y.left=z;
            }else{
                y.right=z;
            }
        }


    }
    //插入
    public void insert(int key){
        BSTNode bstNode = new BSTNode(key, null, null, null);
        if(bstNode!=null){
            insert(this,bstNode);
        }
    }
    //删除
    //如果是子节点 直接删除
    //如果只有左或者右 左替换
    //如果都有则找前驱 替换 前驱必定是叶子节点
    public BSTNode remove(BST tree,BSTNode z){
        BSTNode x=null;
        BSTNode y=null;
        //左右有一个为null 由孩子节点替换
        if(z.left==null||z.right==null){
            y=z;
        }else{
            y=predecessor(z);
        }
        System.out.println("111"+y.key);
        if(y.left!=null){
            x=y.left;
        }else{
            x=y.right;
        }


        if(x!=null){
            x.parent=y.parent;
        }

        if (y.parent == null)
            tree.root = x;
        else if (y == y.parent.left)
            y.parent.left = x;
        else
            y.parent.right = x;

        if(y!=z){
            z.key=y.key;
        }
        return y;
    }
    public void remove(int key){
        BSTNode z,node;
        if((z=find(root,key))!=null){
            if((node=remove(this,z))!=null){
                node=null;
            }
        }
    }


    //销毁
    private void destory(BSTNode root){
        if(root==null){
            return;
        }
        if(root.left!=null){
            destory(root.left);
        }
        if(root.right!=null){
            destory(root.right);
        }
        root=null;
    }
    public void destory(){
        destory(root);
        root=null;
    }

    //打印
    private void print(BSTNode tree, int key, int direction) {

        if(tree != null) {

            if(direction==0)    // tree是根节点
                System.out.printf("%2d is root\n", tree.key);
            else                // tree是分支节点
                System.out.printf("%2d is %2d's %6s child\n", tree.key, key, direction==1?"right" : "left");

            print(tree.left, tree.key, -1);
            print(tree.right,tree.key,  1);
        }
    }

    public void print() {
        if (root != null)
            print(root, root.key, 0);
    }
    public static void main(String[] args) {
        final int arr[] = {10,5,15,4,6,12,16,14,13,3};

        int i, ilen;
        BST tree=new BST();

        System.out.print("== 依次添加: ");
        ilen = arr.length;
        for(i=0; i<ilen; i++) {
            System.out.print(arr[i]+" ");
            tree.insert(arr[i]);
        }

        System.out.print("\n== 前序遍历: ");
        tree.preOrder();

        System.out.print("\n== 中序遍历: ");
        tree.midOrder();

        System.out.print("\n== 后序遍历: ");
        tree.postOrder();
        System.out.println();

        System.out.println("== 最小值: "+ tree.min());
        System.out.println("== 最大值: "+ tree.max());
        System.out.println("== 树的详细信息: ");
        tree.print();

        System.out.print("\n== 删除根节点: "+ arr[2]);
        tree.remove(arr[2]);

        System.out.print("\n== 中序遍历: ");
        tree.midOrder();
        System.out.println();

        // 销毁二叉树
        tree.destory();
    }
}
```





### 冒泡排序 每次前一个和后一个比较 将大的放在后面

```java
int[] nums={2,4,5,7,3,1};
int n=nums.length;
for(int i=n-1;i>0;i--){
    for(int j=0;j<i;j++){
        if(nums[j]>nums[j+1]){
            int temp=num[j];
            nums[j]=nums[j+1];
            nums[j+1]=temp;
        }
    }
}
return nums;
```

### 快速排序 比基准小 放左边 比基准大放右边

```java
int[] nums={2,4,5,7,3,1};
int n=nums.length;
public int[] quickSort(int l,int r,int[] nums){
    if(l<r){
        int i=l;
        int j=r;
        int x=nums[i];
        while(i<j){
            while(i<j&&nums[j]>x){
                j--;
            }
            if(i<j){
                nums[i]=nums[j];
                i++;
            }
            while(i<j&&nums[i]<x){
                i++;
            }
            if(i<j){
                nums[j]=nums[i];
                j--;
            }
        }
        nums[i]=x;
        quickSort(l,i-1,nums);
        quickSort(i+1,r,nums);
    }
    return nums;
}
```

### 插入排序 总认为前i 个是有序的 在前i 个中找到合适位置 移动 插入

```java
public static int[] sort3(int[] nums){
        int i,j,k;
        for(i=1;i<nums.length;i++){
            for (j=i-1;j>=0;j--){
                if(nums[i]>nums[j]){
                    break;
                }
            }
            if(j!=i-1){
                int temp=nums[i];
                for(k=i-1;k>j;k--){
                    nums[k+1]=nums[k];
                }
                nums[k+1]=temp;
            }
        }
        return nums;
    }
```



### 平时常用的开发工具库有哪些？

common

hultool

### Java常用的JSON库有哪些？有啥注意点？

FastJson 漏洞多

jackJson

Gson

### Lombok工具库用来解决什么问题？

让一类编程可用的类 帮我们生成一下方法

### 为什么很多公司禁止使用lombok？

破坏了封装性

代码可读性低

很强的侵入性

### MapStruct工具库用来解决什么问题？

是来进行拷贝类的

### Lombok和MapStruct工具库的原理？

原理是在编译期通过修改抽象语法树生成代码 

### 开发中有哪些常见的Web安全漏洞？

注入式攻击

XSS

CSRF

### 什么是注入攻击？举例说明？

注入攻击 比如数据库注入式攻击 密码写为or 1==1 则永远正确

解决办法 加密 校验 预处理 错误消息处理

### 什么是CSRF？举例说明并给出开发中解决方案？

盗用你的信息来访问网站

看不到cookie，但是可以盗取使用

解决办法 reffer 验证 http header 加入自定义验证 请求参数加入token 自定义CSRF过滤器

 ### 什么是XSS？举例说明？

反射型攻击 存储型攻击 DOM型攻击

反射就是输入一些语句 页面显示这些非法语句

存储型 把一些操作存到数据库 影响其他用户

DOM型就是 写入js 

防范

转义字符

客户端 服务端加校验

### 一般的渗透测试流程？

确定目标 开始渗透 渗透报告

### 谈谈你对单元测试的理解？

为系统中最小的测试 保证系统正常运行



什么时候写单元测试 边写业务边写单元测试

单元测试多细

核心代码

逻辑复杂

复用的

容易出错

不易理解

### JUnit 5整体架构？

三部分 平台 jupiter vintage

### JUnit 5与Junit4的差别在哪里？

有一些命令不一样了

Before BeforeEach

After AfterEach

BeforeClass BeforeAll

AfterClass AfterAll

### 你在开发中使用什么框架来做单元测试？

junit

mockito

### 你们项目中是如何保证代码质量的？

sonarlint

### 你们项目中是如何做code review的？

合并和定期线下review

### 如何去除多余的if else？

枚举

工厂模式

命令模式

### 如何去除不必要的!=判空？

空对象模式

Optional

### 什么是Spring框架？

Spring是一个轻量级的框架 我们通常所说的Spring 都是Springframework ,旨在提高开发效率

### 列举一些重要的Spring模块？

spring-web

spring-jdbc

spring-aop

### 什么是IOC? 如何实现的？

IOC是一种设计思想，指的是控制反转，将对象的创建和管理交给ioc容器。是用工厂模式和反射实现的

### 什么是AOP? 有哪些AOP的概念？

Aop是面向切面编程，把一些非业务代码封装起来，降低重用代码量

切入点 目标对象 aop代理 织入 通知

### AOP 有哪些应用场景？

日志 事务 监控

### 有哪些AOP Advice通知的类型？

环绕

前置

后置

后置返回

后置异常

### AOP 有哪些实现方式？

静态代理：通过编译器实现，编译时增强 

编译器

类加载器

动态代理：运行时动态生成，运行时增强

jdk

cglib

### 谈谈你对CGLib的理解？

jdk 通过实现接口

CGlib 是通过继承被代理的对象，生成一个子类进行增强得到的代理对象。

### Spring AOP和AspectJ AOP有什么区别？

Spring AOP基于代理的 动态代理

AspectJ AOP基于字节码的 静态代理

切面比较多时 AspectJ AOP 效率高

### Spring中的bean的作用域有哪些？

单例

每次都创建

request 创建

session 创建

global-session 全局session

### Spring中的单例bean的线程安全问题了解吗？

多个线程对非静态成员变量会出现线程安全问题

ThreadLocal解决

### Spring中的bean生命周期？

实例化 配置属性 初始化 使用

### 说说自己对于Spring MVC的了解？

MVC是一种设计模式，SpringMVC是一个MVC框架，分为三层 model view controller

### Spring MVC的工作原理了解嘛？

客户端请求过来 先经过dispatcher selevert 根据HandlerMapping 找到handler HandlerAdapter 找到对应的handle 执行真正的业务处理 返回一个ModelAndView 视图解析器解析返回一个view 并将Model 装入 返回给客户端

### Spring框架中用到了哪些设计模式？

工厂

外观

适配器

### @Component和@Bean的区别是什么？

@Component作用在类上

根据类扫描路径 加载类

@Bean作用在方法上，更适用，很多地方都需要根据@Bean注册bean

### 将一个类声明为Spring的bean的注解有哪些？

Controller

Service

Repository

Component

Bean

### Spring事务管理的方式有几种？

编程式

硬编码

声明式

注解或者xml

### Spring事务中的隔离级别有哪几种？

使用底层数据库的

读未提交

读已提交

可重复读

串行化

### Spring事务中有哪几种事务传播行为？

支持当前事务

有加入 没有创建

加入 非事务运行

加入 抛出异常

不支持当前事务

有挂起 开启新的

有挂起 非事务运行

有抛出异常 非事务运行

其他

作为一个嵌套执行 没有创建新的

### Bean Factory和ApplicationContext有什么区别？

ApplicationContext 提供文件解析和文件资源处理的方法

### 如何定义bean的范围？

scope

### 可以通过多少种方式完成依赖注入？

构造方法

setter

接口注入

### 什么是SpringBoot？

SpringBoot 是spring开源项目的一个框架 简化配置 帮助开发者快速上手

### 什么是SpringBoot？

独立运行

简化配置

自动配置

无生成代码和xml配置

应用监控

### Spring、Spring MVC和SpringBoot有什么区别？

Spring 核心 提供了ioc apo

Spring MVC 进行了分层设计

SpringBoot简化 spring和springmvc的配置

### SpringBoot自动配置的原理?

通过每个starter中的spring.factory 将其自动注入进去

###  Spring Boot的核心注解是哪些？他主由哪几个注解组成的？

springbootapplication

enableAutoconfiguration

configauration

componentscan

### SpringBoot的核心配置文件有哪几个？他们的区别是什么？

application

bootstrap

支持微服务中将配置放到远程

### 什么是Spring Boot Starter？有哪些常用的？

封装好的一些应用 简化配置

jdbc

web

test

### spring-boot-starter-parent有什么作用？

java 编译环境

utf-8编码

引入依赖

自动化资源过滤

自动化插件配置

### 如何自定义Spring Boot Starter？

@EnableConfiguration

meta-info spring.factory

### 为什么需要spring-boot-maven-plugin？

运行

打包

管理声明周期

### SpringBoot 打成jar和普通的jar有什么区别？

直接运行

不能运行

不能引用

引用

### 如何使用Spring Boot实现异常处理？

controllerAdvice

### SpringBoot 实现热部署有哪几种方式？

springboot-loaded

springboot-devtools

### Spring Boot中的监视器是什么？

actuator

### Spring Boot 可以兼容老 Spring 项目吗？

import resource

### 什么是Spring Security？核心功能？

是spring的安全框架

认证 授权 攻击防护盗用身份 crsf

### Spring Security的原理?

认证

securitycontexthodler

授权

accessDecisionManager

### Spring Security基于用户名和密码的认证模式流程？

认证 认证成功鉴权

返回登录页面

### 什么是日志系统和日志门面？分别有哪些框架？

日志系统真正可以执行的日志框架 日志门面不能执行 必须动态注入日志组件

系统

logfj

logfj2

logback

门面

slf4j

### 日志库中使用桥接模式解决什么问题？

将一个日志转换为另一个日志

### 在日志配置时会考虑哪些点？

等级

按天

最多保留多少天

### 对Java日志组件选型的建议？

性能要求高 log4j2

功能上 logback

### 对日志架构使用比较好的实践？

避免不必要的输出

输出中要带上行号和函数名

### 对现有系统日志架构的改造建议？

利用桥接模式

### Tomcat 整体架构的设计？

server connector service container

### Tomcat 一个请求的处理流程？

先到server 再到connector 再到具体的servece 再到执行引擎 再到host 再到 context 再到wrapper 构造httprequest httpresponse 返回

### Tomcat 中类加载机制？

用三个  commonLoader  commonLoader  sharedLoader 

不同于双亲委派

为了隔离线程

### Tomcat Container设计？

执行引擎

host

context

wrapper

### Tomcat LifeCycle机制？

客户端 server connect service Excutor 执行引擎 host context wrapper

### Tomcat 中Executor?

Tomcat希望将Executor也纳入Lifecycle**生命周期管理**，所以让它实现了Lifecycle接口

到达最大线程数后有一个超时时间

### Tomcat 中的设计模式？

外观模式

责任链模式

观察者模式









### Git中5个区，和具体操作？

工作区 add 暂存区 commit 本地仓库 push 远程仓库

checkout reset --hard

### 平时是怎么提交代码的？

git add 

git commit

git pull -rebase

git push

### Maven中包的依赖原则？如何解决冲突？

最短距离原则

子pom 覆盖父pom

最先声明原则



解决 查看依赖树 找到冲突的 execlude

### Maven 项目生命周期与构建原理？

构建生命周期

清理生命周期

站点声明周期

### 在开发中缓存具体如何实现？

本地缓存 局部变量

分布式缓存 redis+springcache

### 使用缓存的经验？

频繁修改的不适合做缓存

热数据要预加载

没有热点的不需要缓存

### 什么是限流？三种限流的算法？

限流指的是某一段时间流量过大为了保证系统的可用性，放弃某些流量

令牌桶算法

漏桶算法

计数器

### 限流令牌桶和漏桶对比？

令牌桶算法是每次往里面放n个令牌，然后去获取，如果令牌不够就拒绝

漏桶是把把流量放进桶里，桶满了再拒绝 以固定的流速通过

令牌 流量突增 漏桶不行

### 在单机情况下如何实现限流？

限流接口

限流请求资源

限流总响应数

### 在分布式环境下如何实现限流？

redis+lua 脚本实现

### 为什么会有容错？一般有哪些方式解决容错相关问题？

容错指的是依赖的服务挂了以后导致请求堆积，引发雪崩效应。

限流

熔断

超时

降级

隔离

### 谈谈你对服务降级的理解？

服务降级是 当一些业务无法正常响应时返回统一错误信息

### 什么是服务熔断？和服务降级有什么区别？

服务熔断指的是 大量的请求过来，由于下游服务出现异常，所以需要立即中断，是一种服务链路保护机制

强调是下游 降级时整体负载

### 如何设计服务的熔断？

异常

日志

手动重置

### 服务熔断有哪些实现方案？

Hystrix

sentinel

### 什么是负载均衡？原理是什么？

负载均衡指的是 将请求均衡的分发到每一个服务节点

原理是一台机器承担不了压力 所以增加多台

### 负载均衡有哪些分类？

ip mac dns

### 常见的负载均衡服务器有哪些？

nginx

### 常见的负载均衡的算法？

轮询

加权轮询

随机

加权随机

哈希

最小连接数

### 什么是容灾？一般基于什么实现？

容灾指的是 发生一定故障后，仍然对外可用

数据备份 故障转移

### 一般怎么实现灾备？

数据备份 异地进行数据备份

应用备份 异地部署应用 出现问题 异地切换

### 什么是分布式系统的副本一致性？有哪些？

分布式系统副本一致性指的是 不管从哪个服务访问，得到的数据在约束条件下都是一样的

有

强一致性

单调一致性

会话一致性

弱一致性

最终一致性

### 在分布式系统中有哪些常见的一致性算法？

hash 算法

paxos

raft 算法

### 谈谈你对一致性hash算法的理解？

利用hash 保证一致性 

环状hash 保证单调性 有新的加入时 要么到新的上面或者还在原来的上面 不会到旧的缓冲区中

虚拟节点保证 平衡性 分配的更加均衡

分散性 一个内容被不同的终端分到了不同的hash

负载 一个内容被不同的用户映射到不同的hash

### 什么是Paxos算法？ 如何实现的？

paxos 算法里面有三个 提议者 表决者 学习者

提议者提议后，由表决者进行表决，如果多数表决者同意 那么学习者进行学习

### 什么是Raft算法？

Raft算法有 领导者 跟随者 候选者

在跟随者接收不到领导者发送过来的消息时，就会出发选择机制

该节点变为候选者，发起候选，大多数跟随者同意后且没有收到其他领导者发送过来的消息，变为领导者。

### 全局唯一ID有哪些实现方案？

数据库方法

雪花算法

数据库算法中有

基于mysql

每个数据库设置不同的初始值和增量

redis 自增命令 incy incyby

雪花算法

有第一位符号位 然后1-42 时间戳 10 机器位 12 序号

存在时间回拨问题

第一种是从数据库中取出来最新的把它放入

第二种是缓存 每次生成一堆 使用 不足时再生成

使用原子时间递增的方法

### 有哪些方案实现分布式锁？

mysql 

redis

zookeeper



存一条数据

悲观锁

乐观锁

redis 

set  nx px 命令 解锁用lua脚本 确保有

redLock  在大多数节点上都加锁，建锁时间小于超时时间 创建成功 否则失败 依次遍历每个删除 如果上一个还存在锁 则一直尝试

redission 有看门狗自动续期

zookeeper 排号 叫号最小的执行 执行完后唤醒下一个

### 什么是ACID？

原子性

一致性

隔离性

持久性

### 分布式事务有哪些解决方案？

seata

### 什么是分布式的XA协议？

XA协议是基于数据库的分布式事务协议，分为事务管理器和本地资源管理器。

### 什么是2PC？

两阶段提交

第一个阶段先准备提交

都回复yes 再提交

### 什么是3PC?

三阶段提交

try can do

### 什么是TCC？

TCC是基于业务的两阶段提交

try confirm cancel

### 分布式系统中常用的缓存方案有哪些？

客户端缓存

nginx 缓存

数据库缓存

### 分布式系统缓存的更新模式？



wirte/read aside

读就读 缓存中没有再去读数据库 写数据库删缓存



wirte/read through

读 缓存有读 没有数据库写入缓存 修改先修改缓存 再修改数据库

write back

走缓存

异步方式同步

 ### 分布式系统缓存淘汰策略

lru 最近最少使用

lfu 最近使用次数最少

fifo 先进先出

### Java中定时任务是有些？如何演化的？

timer 

scheduledExecute

SpringTask

Quartz

### 常见的JOB实现方案？

elstic-job

xxl-job

### Cookie和Session有什么区别？

cookie 保存在客户端

session 保存在服务端

但是如果session 由服务端生成发送给客户端 客户端请求时需要在cookie 使用

### 谈谈会话技术的发展？

单机器

springsession

### 分布式会话有哪些解决方案？

springsession

jwt

### 什么是Session Stick?

每个服务保存自己的session 负载均衡根据自己的进行转发

### 什么是Session Replication？

增加session共享

### 什么是Session 数据集中存储？

数据库存储session

### 什么是Cookie Based Session?

每次cookie 都生成一个新的session

### 什么是JWT？使用JWT的流程？对比传统的会话有啥区别？

jwt 包含三部分 header 加密算法 payload 数据 signare 签名 

客户端请求 生成jwt 返回给客户端 客户端放入请求头中 给我们 我们根据jwt 重新生成签名 进行比较

无状态

安全

多平台跨域

### 如何设计一个秒杀系统？

限流 前端 后端 限流

动静分离









